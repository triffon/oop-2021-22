# struct

Можем да груприаме произволни типове данни, които описват някаква обща концепция. Например една точка в двумерното пространство има координати (x, y). Удобно е да можем да разглеждаме конкретена точка като съвкупност от нейните координати.  
   
Чрез структурите дефинираме тип, съставен от други типове. Обект от този тип съдържа в себе си обекти от другите типове, като те са последвателно наредени в паметта.

## Дефиниране и инициализация

```c++
// Дефинираме нов тип `Pоint`, който е съставен от `int` и `int`. 

struct Point{
    int x;
    int y;
};

//...

int main(){
    // Създаваме обект от тип `Point`
    Point p;
    // За да инициализираме p, трябва да инициализираме всиките членове
    p.x = 1;
    p.y = -1;
}
```
Типът може да се дефинира глобално както горе и да се използва във всички scope-ове на програмата или да се дефинира локално и да се използва само в съответния scope. 

### Анонимни структури
```c++
// Обект `p` от тип анонимна структура, съставена от два `int`-a.

struct {
    int x;
    int y;
} p;
```
### Динамичнo заделени обекти и масиви
```c++
int main(){
    Point* p = new Point;
    //...
    delete p;

    Point* arr = new Point[10];
    //...
    delete[] arr;
}
```
## Членове

В дадените по-горе примери членовете са `x` и `y`. 
- Достъпваме елементите за *конкретен* обект `Point p` чрез оператор `'.'` така: `p.x`, `p.y`.
- Ако имаме указател `Point* pPtr`, достъпваме елементите на обекта, към който сочи указателя чрез оператор `'->'` така: `p->x`, `p->y`.   
   
Членовете на константни обекти не могат да бъдат променяни.

## Фунцкии

Структурите, както простите типове, могат да се подават на функции. Обектите могат да са много обемни, за това не искаме при всяко подаване да се копират.

- Подаваме чрез псевдоним
```c++
void setPoint(Point& p){
    std::cin >> p.x;
    std::cin >> p.y;
}

void printPoint(const Point& p){
    // тук не можем да променяме стойностите на `x` и `y` за обекта `p`
    std::cout << '(' << p.x << ", " << p.y << ')' << std::endl;
}
```
```c++
Point p;
setPoint(p);
printPoint(p);
```
- Подаваме чрез указател
```c++
void setPoint(Point* p){
    std::cin >> p->x;
    std::cin >> p->y;
}

void printPoint(const Point* p){
    std::cout << '(' << p->x << ", " << p->y << ')' << std::endl;
}
```
```c++
Point p;
setPoint(&p);
printPoint(&p);
```
## Динамично заделени членове

*Ако ни се наложи да имаме динамично заделен масив в обекта, трябва да се грижим за паметта!*

```c++
struct Person{
    char* firstName;
    char* lastName;
    size_t age;
};

void allocPerson(Person& p){
    p.firstName = new char[MAX_SIZE];
    p.lastName = new char[MAX_SIZE];
}

void deallocPerson(Person& p){
    delete[] p.firstName;
    delete[] p.lastName;
}
```

# enum
 enum е специален тип, чрез който се дават имена на група от конкретни константи. Константите се наричат *енумератори* и всяка от тях е от този специален тип. Могат имплицитно да се конвертират към `int` и са достъпни в целия scope, в който се намират. 

## Дефиниране и инициализация
Изброява се поредица от константи, като по подразбиране първата се приравнява на 0 и всяка е с 1 по-голяма от предходната.
```c++
enum Direction{
    UP,   // = 0
    DOWN, // = 1
    LEFT, // = 2
    RIGHT // = 3
};
```
Може да се дадат конкретни стойности на някои/всички от константите
```c++
enum Color{
    RED = -5,   // = -5
    GREEN,      // = -4
    BLUE,       // = -3
    YELLOW = 6, // = 6
    PURPLE,     // = 7
    BLACK       // = 8
}
```
Инициализират се както нормални променливи, *НО* стойността, която даваме може да е само една от изброените в групата!
```c++
// Валидни стойности
Direction direction = UP;
Color color = BLUE;

// Тези стойности не са валидни!
Direction invalid_direction = SOUTH; 
Color invalid_color = ORANGE; 
```

